---
timestamp: 'Fri Nov 07 2025 01:27:24 GMT-0500 (Eastern Standard Time)'
parent: '[[../20251107_012724.6256d06a.md]]'
content_id: 73a9a9ece4e8bd626521db4fac9c8f2eff2bba10f45852cc5fef29f6cc5295ba
---

# API Concept Synchronizations in Circle Frontend

This document outlines all the synchronizations and relationships between different API concepts used throughout the Circle application.

## Overview

The Circle application uses **5 main API concepts** that work together to provide a cohesive user experience:

1. **UserAuthentication** - User identity and authentication
2. **Event** - Event creation and management
3. **UserInterest** - Personal interests and item interests (events)
4. **Friending** - Social connections between users
5. **Reviewing** - User reviews and ratings for events

***

## 1. UserAuthentication ↔ All Other Concepts

### Synchronization Pattern: **User ID Resolution and Username Lookup**

**Purpose**: UserAuthentication serves as the central identity provider. All other concepts use user IDs, but the frontend needs to display usernames.

#### 1.1 UserAuthentication ↔ Friending

* **Location**: `ProfilePage.vue`, `DiscoveryPage.vue`
* **Synchronization**:
  * **Friend List Display**: When displaying friends, `Friending._getFriends()` returns user IDs → `UserAuthentication._getUsername()` resolves IDs to usernames
  * **Friend Requests**: Incoming/outgoing friend requests return user IDs → usernames are fetched for display
  * **Send Friend Request**: User enters username → `UserAuthentication._getUserByUsername()` converts username to user ID → `Friending.sendFriendRequest()` uses the ID
* **Code Reference**:
  ```javascript
  // ProfilePage.vue - Loading friend usernames
  const friendId = friendItem.friend
  const usernameResponse = await authAPI.getUsername(friendId)

  // ProfilePage.vue - Resolving username to ID for friend requests
  const targetUserResponse = await authAPI.getUserByUsername(targetUsername)
  const targetUserId = targetUserResponse.data[0].user
  await friendingAPI.sendFriendRequest(userId, targetUserId)
  ```

#### 1.2 UserAuthentication ↔ Event

* **Location**: `EventCard.vue`, `EventManagerPage.vue`, `EventHistoryPage.vue`
* **Synchronization**:
  * **Organizer Display**: Events contain `organizer` (user ID) → `UserAuthentication._getUsername()` resolves to username for display
  * **Event Creation**: User ID from authentication state → `Event.createEvent()` uses it as `organizer`
* **Code Reference**:
  ```javascript
  // EventCard.vue - Fetching organizer username
  const response = await authAPI.getUsername(this.event.organizer)

  // EventManagerPage.vue - Event creation uses authenticated user as organizer
  await eventAPI.createEvent({ organizer: this.user, ...eventData })
  ```

#### 1.3 UserAuthentication ↔ UserInterest

* **Location**: `ProfilePage.vue`, `DiscoveryPage.vue`
* **Synchronization**:
  * **Personal Interests**: Authenticated user ID → `UserInterest.getPersonalInterests(user)` retrieves user's tags
  * **Item Interests**: Authenticated user ID → `UserInterest.getItemInterests(user)` retrieves events user is interested in
* **Code Reference**:
  ```javascript
  // ProfilePage.vue - Adding personal interest
  await interestAPI.addPersonalInterest(this.user, tag)

  // DiscoveryPage.vue - Getting personal interests for recommendations
  const userInterestsResponse = await interestAPI.getPersonalInterests(this.currentUser)
  ```

#### 1.4 UserAuthentication ↔ Reviewing

* **Location**: `EventHistoryPage.vue`, `ProfilePage.vue`
* **Synchronization**:
  * **Review Creation**: Authenticated user ID → `Reviewing.addReview(user, item, rating, entry)`
  * **Review Retrieval**: User ID → `Reviewing.getReviewsByUser(user)` retrieves all reviews by that user
* **Code Reference**:
  ```javascript
  // EventHistoryPage.vue - Adding review
  await reviewingAPI.addReview(this.currentUser, eventId, rating, entry)
  ```

***

## 2. Event ↔ UserInterest

### Synchronization Pattern: **Event Interest Tracking and Recommendations**

**Purpose**: Users can mark events (items) as interested, and this interest data drives recommendations and discovery.

#### 2.1 Event Creation → UserInterest Tracking

* **Location**: `EventCard.vue`, `DiscoveryPage.vue`
* **Synchronization**:
  * When a user marks an event as interested → `UserInterest.addItemInterest(user, event._id)` creates the relationship
  * The event ID becomes an "item" in the UserInterest concept
* **Code Reference**:
  ```javascript
  // EventCard.vue - Toggling interest (handled by parent)
  // DiscoveryPage.vue - Handling interest changes
  if (isInterested) {
    await interestAPI.addItemInterest(this.currentUser, eventId)
  } else {
    await interestAPI.removeItemInterest(this.currentUser, eventId)
  }
  ```

#### 2.2 UserInterest → Event Recommendations

* **Location**: `DiscoveryPage.vue`
* **Synchronization**:
  * **Personal Interests → Recommendations**: `UserInterest.getPersonalInterests(user)` → tags converted to filters → `Event.getEventsByRecommendationContext(user, filters, priorities)` returns personalized events
  * **Item Interests → Discovery**: `UserInterest.getItemInterests(user)` returns event IDs → `Event.getEventById()` resolves each ID to full event data
* **Code Reference**:
  ```javascript
  // DiscoveryPage.vue - Loading recommended events
  const userInterestsResponse = await interestAPI.getPersonalInterests(this.currentUser)
  const userInterests = userInterestsResponse.data.map(item => item.tag)
  const filtersStr = userInterests.join(',')
  const recommendationResponse = await eventAPI.getEventsByRecommendationContext(
    this.currentUser, filtersStr, 'upcoming'
  )
  ```

#### 2.3 Event → UserInterest Count Display

* **Location**: `EventManagerPage.vue`
* **Synchronization**:
  * Event organizer wants to see how many users are interested → `UserInterest.getUsersInterestedInItems(event._id)` returns list of interested users → count displayed on event card
* **Code Reference**:
  ```javascript
  // EventManagerPage.vue - Loading interested users count
  const response = await interestAPI.getUsersInterestedInItems(event._id)
  this.interestedUsersCount[event._id] = response.data.length
  ```

#### 2.4 Event Status → UserInterest Display

* **Location**: `EventManagerPage.vue`, `EventHistoryPage.vue`
* **Synchronization**:
  * `UserInterest.getItemInterests(user)` returns all event IDs user is interested in → `Event.getEventById()` for each → filter by status (upcoming/completed) for display
* **Code Reference**:
  ```javascript
  // EventManagerPage.vue - Loading interested events
  const interestsResponse = await interestAPI.getItemInterests(this.currentUser)
  const eventIds = interestsResponse.data.map(item => item.item)
  const events = await Promise.all(eventIds.map(id => eventAPI.getEventById(id)))
  // Filter to only show upcoming events
  ```

***

## 3. Friending ↔ UserInterest

### Synchronization Pattern: **Social Discovery - Friends' Interests**

**Purpose**: Show which friends are interested in events to enable social discovery.

#### 3.1 Friends → Friends' Event Interests

* **Location**: `DiscoveryPage.vue`
* **Synchronization**:
  * `Friending.getFriends(user)` returns friend user IDs → `UserInterest.getItemInterests(friendId)` for each friend → match event IDs to show "Friends Interested" on event cards
* **Code Reference**:
  ```javascript
  // DiscoveryPage.vue - Loading friends' interests
  const friendsResponse = await friendingAPI.getFriends(this.currentUser)
  const friendInterestsPromises = this.friends.map(async (friend) => {
    const interestsResponse = await interestAPI.getItemInterests(friend.friend)
    return { friend, interestedEvents: interestsResponse.data.map(i => i.item) }
  })
  // Build friendsAttendingMap to show on event cards
  ```

#### 3.2 Friends → Username Resolution

* **Location**: `DiscoveryPage.vue`
* **Synchronization**:
  * Friend IDs from `Friending.getFriends()` → `UserAuthentication.getUsername(friendId)` → display friend usernames on event cards
* **Code Reference**:
  ```javascript
  // DiscoveryPage.vue - Fetching friend usernames
  const response = await authAPI.getUsername(friendId)
  const username = response.data[0]?.username || friendId
  ```

***

## 4. Reviewing ↔ Event

### Synchronization Pattern: **Event Reviews and History**

**Purpose**: Users can review events, and reviews are displayed alongside event information.

#### 4.1 Event → Review Creation

* **Location**: `EventHistoryPage.vue`
* **Synchronization**:
  * User views completed event → `Reviewing.addReview(user, event._id, rating, entry)` creates review for that event
  * Event ID is the "item" in the Reviewing concept
* **Code Reference**:
  ```javascript
  // EventHistoryPage.vue - Adding review
  await reviewingAPI.addReview(this.currentUser, event._id, rating, entry)
  ```

#### 4.2 Review → Event Display

* **Location**: `EventHistoryPage.vue`, `ProfilePage.vue`
* **Synchronization**:
  * `Reviewing.getReviewsByUser(user)` returns reviews with `target` (event ID) → `Event.getEventById(review.target)` resolves to full event data for display
* **Code Reference**:
  ```javascript
  // EventHistoryPage.vue - Loading reviews with event data
  const reviewsResponse = await reviewingAPI.getReviewsByUser(this.currentUser)
  const reviewsWithEvents = await Promise.all(
    reviews.map(async (reviewData) => {
      const eventResponse = await eventAPI.getEventById(reviewData.review.target)
      return { review: reviewData.review, event: eventResponse.data[0] }
    })
  )
  ```

#### 4.3 Event Status → Review Eligibility

* **Location**: `EventHistoryPage.vue`
* **Synchronization**:
  * Only `Event.status === 'completed'` events can be reviewed (enforced in UI)
  * `UserInterest.getItemInterests(user)` → `Event.getEventById()` → filter by `status === 'completed'` → show in "Event History" with review capability

***

## 5. ProfilePage: Multi-Concept Aggregation

### Synchronization Pattern: **Recent Activity Feed**

**Location**: `ProfilePage.vue`

**Purpose**: Display aggregated user activity across multiple concepts.

#### 5.1 Recent Activity Synchronization

* **Data Sources**:
  1. **UserInterest**: `getItemInterests(user)` → event IDs → `Event.getEventById()` → "Marked \[event] as interested"
  2. **Reviewing**: `getReviewsByUser(user)` → event IDs → `Event.getEventById()` → "Reviewed \[event] with X stars"
  3. **Event**: `getEventsByOrganizer(user)` → "Created event \[name]"
  4. **Friending**: `getFriends(user)` → "Connected with a new friend"
* **Code Reference**:
  ```javascript
  // ProfilePage.vue - Loading recent activity
  const [interestsResponse, reviewsResponse, eventsResponse, friendsResponse] = await Promise.all([
    interestAPI.getItemInterests(userId),
    reviewingAPI.getReviewsByUser(userId),
    eventAPI.getEventsByOrganizer(userId),
    friendingAPI.getFriends(userId)
  ])
  // Cross-reference with Event API to get event names
  ```

***

## 6. EventManagerPage: Organizer View Synchronization

### Synchronization Pattern: **Event Management with Interest Tracking**

**Location**: `EventManagerPage.vue`

#### 6.1 Organizer Events → Interest Counts

* **Synchronization**:
  * `Event.getEventsByOrganizer(user)` → for each event → `UserInterest.getUsersInterestedInItems(event._id)` → display count on event card
* **Code Reference**:
  ```javascript
  // EventManagerPage.vue
  const eventsResponse = await eventAPI.getEventsByOrganizer(this.user)
  await this.loadInterestedUsersCount(this.userEvents)
  ```

#### 6.2 User's Interested Events Display

* **Synchronization**:
  * `UserInterest.getItemInterests(user)` → event IDs → `Event.getEventById()` for each → filter to `status === 'upcoming'` → display in "Events You're Interested In"
* **Code Reference**:
  ```javascript
  // EventManagerPage.vue
  const interestsResponse = await interestAPI.getItemInterests(this.currentUser)
  const eventPromises = interestedEventIds.map(eventId => eventAPI.getEventById(eventId))
  ```

***

## 7. Cross-Concept Data Flow Patterns

### 7.1 User ID Propagation

* **Pattern**: User ID from `UserAuthentication` (stored in `localStorage` via `useAuth` composable) → propagated to all other API calls
* **Implementation**: `this.user` or `this.currentUser` (computed from `useAuth`) → used as parameter in all concept APIs

### 7.2 ID-to-Name Resolution Chain

* **Pattern**: APIs return IDs → `UserAuthentication._getUsername()` or `Event.getEventById()` resolves to human-readable names
* **Common Pattern**:
  ```
  Friending.getFriends() → [friend IDs]
    → UserAuthentication.getUsername() → [usernames]

  UserInterest.getItemInterests() → [event IDs]
    → Event.getEventById() → [event objects with names]

  Reviewing.getReviewsByUser() → [reviews with event IDs]
    → Event.getEventById() → [event names]
  ```

### 7.3 Parallel Data Loading

* **Pattern**: Multiple API calls made in parallel using `Promise.all()` to optimize performance
* **Examples**:
  * `ProfilePage.loadRecentActivity()`: Loads interests, reviews, events, and friends in parallel
  * `DiscoveryPage.loadFriendsAttendingData()`: Loads all friends' interests in parallel

***

## 8. State Synchronization Mechanisms

### 8.1 Real-Time Updates

* **Polling**: `ProfilePage.vue` uses `setInterval` to poll `loadFriendsData()` every 5 seconds for cross-user friend updates
* **Force Updates**: Vue's `$nextTick()` and `$forceUpdate()` ensure immediate UI reactivity after API operations

### 8.2 Reactive Data Flow

* **Pattern**: API responses update Vue reactive data → UI automatically re-renders
* **Implementation**:
  * API calls in `methods` → update `data()` properties → Vue reactivity system → template re-renders

### 8.3 Error Handling and Fallbacks

* **Pattern**: Graceful degradation when APIs fail
* **Examples**:
  * `DiscoveryPage`: Falls back to mock friends if `Friending.getFriends()` fails
  * `EventManagerPage`: Shows 0 count if `UserInterest.getUsersInterestedInItems()` returns 404

***

## Summary Table

| Concept A | Concept B | Synchronization Type | Location | Purpose |
|-----------|-----------|---------------------|----------|---------|
| UserAuthentication | Friending | ID ↔ Username resolution | ProfilePage, DiscoveryPage | Display friend usernames |
| UserAuthentication | Event | ID ↔ Username resolution | EventCard, EventManagerPage | Display organizer usernames |
| UserAuthentication | UserInterest | User ID propagation | All pages | Track user interests |
| UserAuthentication | Reviewing | User ID propagation | EventHistoryPage | Associate reviews with users |
| Event | UserInterest | Event ID as "item" | DiscoveryPage, EventCard | Mark events as interested |
| Event | UserInterest | Interest count → Event display | EventManagerPage | Show interest counts |
| UserInterest | Event | Personal interests → Recommendations | DiscoveryPage | Personalized event discovery |
| Friending | UserInterest | Friends → Friends' interests | DiscoveryPage | Social discovery |
| Reviewing | Event | Event ID as "target" | EventHistoryPage | Event reviews |
| All Concepts | ProfilePage | Multi-concept aggregation | ProfilePage | Recent activity feed |

***

## Key Takeaways

1. **UserAuthentication is the central identity provider** - All concepts use user IDs, but display requires username resolution
2. **Event serves as the primary content entity** - UserInterest, Reviewing, and Event management all revolve around events
3. **UserInterest bridges discovery and social features** - Personal interests drive recommendations; item interests enable social discovery
4. **Friending enables social context** - Friends' interests are displayed on events for social discovery
5. **Reviewing provides post-event feedback** - Reviews are tied to completed events and displayed in user history
6. **ID resolution is a common pattern** - APIs return IDs; frontend resolves to human-readable names via lookup APIs
7. **Parallel loading optimizes performance** - Multiple API calls are made in parallel where possible
8. **State synchronization uses polling and reactivity** - Polling for cross-user updates; Vue reactivity for local updates
